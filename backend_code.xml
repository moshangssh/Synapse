<?xml version="1.0" ?>
<code_package directory="backend" generated_at="2025-08-12T17:20:29.080863">
  <file path="diagnose_resolve.py" size="4138" modified_time="2025-08-07T13:39:00.736881" mime_type="text/x-python" content_type="text">
    <content>import sys
import os
import logging
import pprint
import json

# 将 backend 目录添加到 sys.path 以便导入 resolve_utils
# This allows the script to be run directly from the backend directory or the root directory.
current_dir = os.path.dirname(os.path.abspath(__file__))
if current_dir not in sys.path:
    sys.path.insert(0, current_dir)

# Now we can import from resolve_utils
try:
    # Import the new helper function
    from resolve_utils import _get_current_timeline
except ImportError:
    print("Error: Could not import from 'resolve_utils'. Make sure the file exists and is in the correct path.")
    sys.exit(1)

def diagnose_subtitle_properties():
    """
    Connects to DaVinci Resolve, retrieves the full property dictionary of the
    first subtitle item on the timeline, and prints it.
    """
    logging.info("Starting subtitle diagnosis...")

    # --- Get Timeline using the helper function ---
    timeline, frame_rate, error = _get_current_timeline()

    # --- Error Handling ---
    if error:
        logging.error(f"Could not get timeline. Error: {error['message']} (Code: {error['code']})")
        print(f"错误: {error['message']}")
        return

    logging.info(f"Successfully accessed Timeline: '{timeline.GetName()}' with Frame Rate: {frame_rate}")

    # --- Subtitle Track and Item Logic ---
    subtitle_track_count = timeline.GetTrackCount("subtitle")
    if subtitle_track_count == 0:
        logging.info("The current timeline does not contain any subtitle tracks.")
        print("提示: 当前时间线上没有字幕轨道。")
        return

    logging.info(f"Found {subtitle_track_count} subtitle track(s). Checking the first one.")

    # Get items from the first subtitle track (index 1)
    subtitle_items = timeline.GetItemListInTrack("subtitle", 1)
    if not subtitle_items:
        logging.info("Subtitle track 1 is empty.")
        print("提示: 第一个字幕轨道是空的，没有字幕内容。")
        return

    logging.info(f"Found {len(subtitle_items)} items in the first subtitle track.")

    # --- Get and Print Properties of the First Item ---
    # Get the first item from the list
    first_item = subtitle_items[0]
    if not first_item:
        logging.warning("The first subtitle item is invalid or None.")
        print("提示: 字幕列表中的第一个项目无效。")
        return

    logging.info(f"Retrieving properties for the first subtitle item...")

    try:
        # Now, GetProperty is called on a single item object
        properties = first_item.GetProperty()

        if not properties or not isinstance(properties, dict):
            logging.warning("GetProperty() returned an empty or invalid dictionary.")
            print("提示: 第一个字幕条目的属性为空或无效。")
            return

        print("\n" + "="*50)
        print("第一个字幕项的完整属性字典:")
        print("="*50)
        
        # Use pprint for readable dictionary output
        pprint.pprint(properties)

        # Also print as JSON for easy parsing if needed
        print("\n" + "="*50)
        print("JSON 格式的属性 (用于程序解析):")
        print("="*50)
        try:
            print(json.dumps(properties, indent=4, ensure_ascii=False))
        except TypeError as e:
            print(f"无法将属性序列化为JSON: {e}")
            print("部分属性可能不是JSON兼容的类型。")


        logging.info("Successfully retrieved and printed subtitle properties.")

    except Exception as e:
        logging.error(f"An error occurred while calling GetProperty(): {e}", exc_info=True)
        print(f"错误: 在获取字幕属性时发生错误: {e}")


if __name__ == "__main__":
    # Configure basic logging for the diagnosis script
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(module)s - %(message)s',
        handlers=[
            logging.StreamHandler(sys.stdout)
        ]
    )
    diagnose_subtitle_properties()</content>
  </file>
  <file path="main.py" size="8325" modified_time="2025-08-12T11:38:58.781846" mime_type="text/x-python" content_type="text">
    <content>from fastapi import FastAPI, HTTPException, Response
from fastapi.middleware.cors import CORSMiddleware
from typing import List, Union

from resolve_utils import get_resolve_subtitles, set_resolve_timecode, generate_srt_content, export_to_davinci, get_resolve_project_info, get_subtitle_tracks
from schemas import (
    SubtitleItem,
    SuccessResponse,
    ErrorResponse,
    TimecodeRequest,
    SubtitleExportRequest,
    SubtitleTrackInfo,
    SubtitleTrackListResponse,
)

app = FastAPI(
    title="DaVinci Resolve Subtitle Extractor API",
    description="一个用于从DaVinci Resolve提取字幕的API",
    version="1.0.0",
)

# CORS (Cross-Origin Resource Sharing) 中间件配置
origins = [
    "http://localhost:1420",  # Tauri应用的默认开发服务器地址
    "tauri://localhost",     # Tauri应用的生产环境地址
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# (Pydantic模型已移至 schemas.py)


# --- 错误处理 ---

def handle_error(error_code: str, error_message: str):
    """根据错误代码，抛出相应的HTTPException。"""
    if error_code in ["resolve_not_running", "connection_error"]:
        raise HTTPException(status_code=503, detail={"status": "error", "message": error_message, "code": error_code})
    elif error_code in ["no_project_open", "no_active_timeline"]:
        raise HTTPException(status_code=404, detail={"status": "error", "message": error_message, "code": error_code})
    elif error_code == "set_timecode_failed":
        raise HTTPException(status_code=400, detail={"status": "error", "message": error_message, "code": error_code})
    elif error_code == "dvr_script_not_found":
        raise HTTPException(status_code=500, detail={"status": "error", "message": error_message, "code": error_code})
    else:
        raise HTTPException(status_code=500, detail={"status": "error", "message": error_message, "code": error_code})


# --- API 端点 ---

@app.post("/api/v1/timeline/timecode",
          tags=["Timeline"],
          summary="设置DaVinci Resolve当前时间线的时间码",
          description="连接到正在运行的DaVinci Resolve实例，并设置当前活动时间线的播放头位置。")
def set_timecode(request: TimecodeRequest):
    """
    ## 功能:
    - 接收一个包含入点、出点和跳转选项的POST请求。
    - 根据 `jump_to` 参数的值（'start', 'end', 'middle'），调用 `set_resolve_timecode` 函数来在Resolve中设置时间码。

    ## 请求体:
    - **in_point (str):** 入点时间码，格式为 "HH:MM:SS:FF"。
    - **out_point (str):** 出点时间码，格式为 "HH:MM:SS:FF"。
    - **jump_to (str):** 跳转位置，可选值为 'start', 'end', 'middle'。

    ## 返回:
    - **成功 (200):** 返回成功信息。
    - **失败 (多种状态码):** 返回包含错误信息的JSON对象。
    """
    status, result = set_resolve_timecode(
        in_point=request.in_point,
        out_point=request.out_point,
        jump_to=request.jump_to.value
    )

    if status == "success":
        return {"status": "success", "message": result.get("message")}

    error_code = result.get("code", "unknown_error")
    error_message = result.get("message", "An unknown error occurred.")
    handle_error(error_code, error_message)


@app.get("/api/v1/timeline/subtitle_tracks",
          response_model=Union[SubtitleTrackListResponse, ErrorResponse],
          tags=["Timeline"],
          summary="获取DaVinci Resolve时间线上所有的字幕轨道",
          description="连接到正在运行的DaVinci Resolve实例，并返回当前活动时间线上所有字幕轨道的列表，包含轨道索引和名称。")
def get_subtitle_tracks_endpoint():
    """
    ## 功能:
    - 连接到 DaVinci Resolve。
    - 获取当前活动时间线。
    - 遍历并返回所有字幕轨道的索引和名称。

    ## 返回:
    - **成功 (200):** 返回包含字幕轨道列表的JSON对象。
    - **失败 (多种状态码):** 返回包含错误信息的JSON对象。
    """
    status, result = get_subtitle_tracks()

    if status == "success":
        return {"status": "success", "data": result.get("data")}

    error_code = result.get("code", "unknown_error")
    error_message = result.get("message", "An unknown error occurred.")
    handle_error(error_code, error_message)


@app.get("/api/v1/subtitles",
         response_model=Union[SuccessResponse, ErrorResponse],
         tags=["Subtitles"],
         summary="提取DaVinci Resolve当前时间线的字幕",
         description="连接到正在运行的DaVinci Resolve实例，并从当前活动时间线的指定字幕轨道中，提取所有字幕条目的起始时间码、结束时间码和文本内容。")
def get_subtitles(track_index: int = 1):
    """
    ## 功能:
    - 连接到 DaVinci Resolve。
    - 获取当前项目和活动时间线。
    - 从指定字幕轨道提取所有字幕。

    ## 查询参数:
    - **track_index (int):** 要提取字幕的轨道索引，默认为 1。

    ## 返回:
    - **成功 (200):** 返回包含字幕数据的JSON对象。
    - **失败 (多种状态码):** 返回包含错误信息的JSON对象。
    """
    status, result = get_resolve_subtitles(track_index=track_index)

    if status == "success":
        return {"status": "success", "frameRate": result.get("frameRate"), "data": result.get("data")}
    
    # 处理来自 resolve_utils 的错误
    error_code = result.get("code", "unknown_error")
    error_message = result.get("message", "An unknown error occurred.")
    handle_error(error_code, error_message)


@app.get("/api/v1/project-info",
         tags=["Project"],
         summary="获取DaVinci Resolve当前项目和时间线信息",
         description="连接到正在运行的DaVinci Resolve实例，并获取当前项目和时间线的名称。")
def get_project_info():
    """
    ## 功能:
    - 连接到 DaVinci Resolve。
    - 获取当前项目名称和活动时间线名称。

    ## 返回:
    - **成功 (200):** 返回包含项目和时间线名称的JSON对象。
    - **失败 (多种状态码):** 返回包含错误信息的JSON对象。
    """
    status, result = get_resolve_project_info()

    if status == "success":
        return {"status": "success", "data": result}
    
    error_code = result.get("code", "unknown_error")
    error_message = result.get("message", "An unknown error occurred.")
    handle_error(error_code, error_message)


@app.get("/", include_in_schema=False)
def read_root():
    return {"message": "Welcome to the DaVinci Resolve Subtitle Extractor API!"}


@app.post("/api/v1/export/srt", tags=["Export"], summary="导出SRT字幕文件")
def export_subtitles_as_srt(request: SubtitleExportRequest):
    srt_content = generate_srt_content(request)
    return Response(content=srt_content, media_type="text/plain")


@app.post("/api/v1/export/davinci", tags=["Export"], summary="直接导出字幕到DaVinci Resolve时间线")
def export_subtitles_to_davinci(request: SubtitleExportRequest):
    """
    ## 功能:
    - 接收包含字幕数据的POST请求。
    - 调用 `export_to_davinci` 函数，该函数会：
        1. 生成一个临时的SRT文件。
        2. 将该文件导入到DaVinci Resolve的媒体池中。
        3. 将导入的字幕媒体项附加到当前时间线。
        4. 清理临时文件。

    ## 请求体:
    - **frameRate (float):** 时间线的帧率。
    - **subtitles (List[SubtitleItem]):** 包含字幕条目的列表。

    ## 返回:
    - **成功 (200):** 返回成功信息。
    - **失败 (多种状态码):** 返回包含错误信息的JSON对象。
    """
    status, result = export_to_davinci(request)

    if status == "success":
        return {"status": "success", "message": result.get("message")}

    error_code = result.get("code", "unknown_error")
    error_message = result.get("message", "An unknown error occurred.")
    handle_error(error_code, error_message)</content>
  </file>
  <file path="requirements.txt" size="44" modified_time="2025-08-12T11:38:58.782844" mime_type="text/plain" content_type="text">
    <content>fastapi
uvicorn[standard]
pytest
Timecode</content>
  </file>
  <file path="resolve_utils.py" size="18479" modified_time="2025-08-07T13:39:00.738351" mime_type="text/x-python" content_type="text">
    <content>import sys
import os
import logging
import importlib.util
import tempfile
from timecode import Timecode
from timecode_utils import format_timecode, timecode_to_frames, frames_to_srt_timecode
from schemas import SubtitleTrackInfo

# 配置日志记录
log_file = os.path.join(os.path.dirname(__file__), 'resolve_connection.log')
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(log_file, mode='a', encoding='utf-8'),
        logging.StreamHandler()
    ]
)

# 全局变量来缓存 Resolve 连接
_resolve_connection = None

def _get_resolve_bmd():
    """
    Dynamically loads the DaVinci Resolve script module from its specific path
    to avoid conflicts with other modules like fusionscript.
    """
    if sys.platform.startswith("darwin"):
        script_module_path = "/Library/Application Support/Blackmagic Design/DaVinci Resolve/Developer/Scripting/Modules/DaVinciResolveScript.py"
    elif sys.platform.startswith("win") or sys.platform.startswith("cygwin"):
        script_module_path = os.getenv("PROGRAMDATA") + "\\Blackmagic Design\\DaVinci Resolve\\Support\\Developer\\Scripting\\Modules\\DaVinciResolveScript.py"
    elif sys.platform.startswith("linux"):
        script_module_path = "/opt/resolve/libs/Fusion/Modules/DaVinciResolveScript.py"
    else:
        raise ImportError("Unsupported operating system")

    if not os.path.exists(script_module_path):
        logging.error(f"DaVinci Resolve scripting module not found at path: {script_module_path}")
        return None

    try:
        # Load the module directly from the file path to ensure the correct one is used.
        spec = importlib.util.spec_from_file_location("DaVinciResolveScript", script_module_path)
        bmd = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(bmd)
        logging.info(f"Successfully imported DaVinciResolveScript module from: {script_module_path}")
        return bmd
    except Exception as e:
        logging.error(f"Failed to import DaVinci Resolve script module from {script_module_path}: {e}", exc_info=True)
        return None

def _connect_to_resolve(force_reconnect=False):
    """
    Loads the DaVinci Resolve script module and connects to the Resolve application.
    It will cache the connection globally to avoid reconnecting on every call.
    
    Args:
        force_reconnect (bool): If True, it will ignore the cached connection
                                and establish a new one.

    Returns a tuple (resolve, error), where resolve is the connection object
    and error is a dictionary with 'code' and 'message' if connection fails.
    """
    global _resolve_connection
    if _resolve_connection and not force_reconnect:
        logging.info("使用缓存的 DaVinci Resolve 连接。")
        return _resolve_connection, None

    dvr_script = _get_resolve_bmd()
    if not dvr_script:
        logging.error("DaVinci Resolve Scripting API module not found.")
        return None, {"code": "dvr_script_not_found", "message": "DaVinci Resolve Scripting API module not found."}

    try:
        # The official documentation is wrong, the scriptapp is in the fusionscript module
        import fusionscript as dvr_script
    except ImportError:
        # Keep the original as a fallback
        pass

    try:
        logging.info("尝试连接到 DaVinci Resolve...")
        resolve = dvr_script.scriptapp("Resolve")
        if not resolve:
            logging.error("无法连接到 DaVinci Resolve。请确保 Resolve 正在运行。")
            _resolve_connection = None # Clear connection on failure
            return None, {"code": "resolve_not_running", "message": "无法连接到 DaVinci Resolve。请确保 Resolve 正在运行。"}
        
        logging.info("成功连接到 DaVinci Resolve。")
        _resolve_connection = resolve # Cache the connection
        return resolve, None
    except Exception as e:
        logging.error(f"连接 DaVinci Resolve 时发生未知错误: {e}", exc_info=True)
        _resolve_connection = None # Clear connection on exception
        return None, {"code": "connection_error", "message": f"连接 DaVinci Resolve 时发生未知错误: {e}"}


def _get_current_timeline():
    """
    Connects to Resolve and retrieves the current timeline object and its frame rate.
    It will attempt to reconnect if the connection is lost.

    Returns:
        A tuple (timeline, frame_rate, error), where timeline is the DaVinci Resolve
        timeline object, frame_rate is a float, and error is a dictionary
        with 'code' and 'message' if an error occurs.
    """
    resolve, error = _connect_to_resolve()
    if error:
        return None, None, error

    try:
        # First, try to get the project manager to check if the connection is alive
        projectManager = resolve.GetProjectManager()
        project = projectManager.GetCurrentProject()
        if not project:
            return None, None, {"code": "no_project_open", "message": "未找到当前打开的项目。"}
    except Exception as e:
        logging.warning(f"DaVinci Resolve 连接可能已断开，正在尝试重新连接... 错误: {e}")
        resolve, error = _connect_to_resolve(force_reconnect=True)
        if error:
            return None, None, error
        projectManager = resolve.GetProjectManager()
        project = projectManager.GetCurrentProject()
        if not project:
            return None, None, {"code": "no_project_open", "message": "重新连接后仍未找到当前打开的项目。"}


    timeline = project.GetCurrentTimeline()
    if not timeline:
        return None, None, {"code": "no_active_timeline", "message": "项目中没有活动的（当前）时间线。"}
    
    try:
        frame_rate_str = timeline.GetSetting('timelineFrameRate')
        frame_rate = float(frame_rate_str)
    except (ValueError, TypeError, AttributeError):
        logging.warning("无法获取时间线帧率，将使用默认值 24.0。")
        frame_rate = 24.0 # Default to a common frame rate

    return timeline, frame_rate, None

def get_resolve_project_info():
    """
    Connects to Resolve and retrieves the current project and timeline names.

    Returns:
        A tuple (status, data), where status is "success" or "error",
        and data is a dictionary with project and timeline names or an error message.
    """
    resolve, error = _connect_to_resolve()
    if error:
        return "error", error

    try:
        projectManager = resolve.GetProjectManager()
        project = projectManager.GetCurrentProject()
        if not project:
            return "error", {"code": "no_project_open", "message": "未找到当前打开的项目。"}
        
        timeline = project.GetCurrentTimeline()
        if not timeline:
            return "success", {"projectName": project.GetName(), "timelineName": None}

        return "success", {"projectName": project.GetName(), "timelineName": timeline.GetName()}

    except Exception as e:
        logging.error(f"获取项目信息时出错: {e}", exc_info=True)
        # Attempt to reconnect
        resolve, error = _connect_to_resolve(force_reconnect=True)
        if error:
            return "error", error
        
        try:
            projectManager = resolve.GetProjectManager()
            project = projectManager.GetCurrentProject()
            if not project:
                return "error", {"code": "no_project_open", "message": "重新连接后仍未找到当前打开的项目。"}
            
            timeline = project.GetCurrentTimeline()
            if not timeline:
                 return "success", {"projectName": project.GetName(), "timelineName": None}

            return "success", {"projectName": project.GetName(), "timelineName": timeline.GetName()}
        except Exception as final_e:
            logging.error(f"重新连接后获取项目信息时仍然出错: {final_e}", exc_info=True)
            return "error", {"code": "get_info_failed", "message": f"获取项目信息失败: {final_e}"}


def get_subtitle_tracks():
    """
    连接到 DaVinci Resolve 并获取当前时间线上所有字幕轨道的列表。

    Returns:
        一个元组 (status, data)，其中 status 是 "success" 或 "error",
        data 是包含轨道信息的列表或错误信息字典。
    """
    timeline, _, error = _get_current_timeline()
    if error:
        return "error", error

    track_count = timeline.GetTrackCount("subtitle")
    if track_count == 0:
        return "success", {"data": []}

    tracks_data = []
    for i in range(1, track_count + 1):
        track_name = timeline.GetTrackName("subtitle", i)
        tracks_data.append(SubtitleTrackInfo(track_index=i, track_name=track_name))

    return "success", {"data": tracks_data}


def get_resolve_subtitles(track_index: int = 1):
    """
    连接到 DaVinci Resolve 并从指定轨道提取当前时间线的字幕信息。

    Args:
        track_index (int): 要提取字幕的轨道索引，默认为 1。

    Returns:
        一个元组 (status, data), 其中 status 是 "success" 或 "error",
        data 是字幕列表或错误信息字典。
    """
    timeline, frame_rate, error = _get_current_timeline()
    if error:
        return "error", error
        
    # 3. 访问字幕轨道
    subtitle_track_count = timeline.GetTrackCount("subtitle")
    if subtitle_track_count == 0:
        return "success", {"frameRate": frame_rate, "data": []}

    if not (1 &lt;= track_index &lt;= subtitle_track_count):
        return "error", {"code": "invalid_track_index", "message": f"无效的字幕轨道索引: {track_index}。有效范围是 1 到 {subtitle_track_count}。"}

    # 从指定的字幕轨道提取
    subtitle_items = timeline.GetItemListInTrack("subtitle", track_index)
    if not subtitle_items:
        return "success", {"frameRate": frame_rate, "data": []}

    # 4. 遍历字幕条目并提取信息
    extracted_data = []
    for index, item in enumerate(subtitle_items):
        start_frame = item.GetStart()
        end_frame = item.GetEnd()
        
        text_content = item.GetName()

        start_timecode = format_timecode(start_frame, frame_rate)
        end_timecode = format_timecode(end_frame, frame_rate)

        subtitle_entry = {
            "id": index + 1,
            "startTimecode": start_timecode,
            "endTimecode": end_timecode,
            "text": text_content,
        }
        extracted_data.append(subtitle_entry)
        
    return "success", {"frameRate": frame_rate, "data": extracted_data}

from timecode_utils import timecode_to_frames, frames_to_timecode, frames_to_srt_timecode

def set_resolve_timecode(in_point: str, out_point: str, jump_to: str):
    """
    在 DaVinci Resolve 中设置当前时间线的时间码。

    Args:
        in_point (str): 入点时间码，格式为 "HH:MM:SS:FF"。
        out_point (str): 出点时间码，格式为 "HH:MM:SS:FF"。
        jump_to (str): 跳转位置，可以是 'start', 'end', 'middle'。

    Returns:
        一个元组 (status, data)，其中 status 是 "success" 或 "error",
        data 是成功信息或错误信息字典。
    """
    timeline, frame_rate, error = _get_current_timeline()
    if error:
        return "error", error

    target_timecode = ""
    if jump_to == "start":
        target_timecode = in_point
    elif jump_to == "end":
        target_timecode = out_point
    elif jump_to == "middle":
        in_frames = timecode_to_frames(in_point, frame_rate)
        out_frames = timecode_to_frames(out_point, frame_rate)
        middle_frames = (in_frames + out_frames) // 2
        target_timecode = frames_to_timecode(middle_frames, frame_rate)

    try:
        timeline.SetCurrentTimecode(target_timecode)
        logging.info(f"成功将时间码设置为: {target_timecode}")
        return "success", {"message": f"成功将时间码设置为: {target_timecode}"}
    except Exception as e:
        logging.error(f"设置时间码时出错: {e}", exc_info=True)
        return "error", {"code": "set_timecode_failed", "message": f"设置时间码时出错: {e}"}
from schemas import SubtitleExportRequest


def generate_srt_content(request: SubtitleExportRequest, base_frames: int = 0) -&gt; str:
    """
    Generates a string in SRT format from a list of subtitle objects.
    """
    srt_blocks = []
    frame_rate = request.frameRate

    for index, subtitle in enumerate(request.subtitles, start=1):
        # 1. Reconstruct clean text from diffs
        clean_text = "".join([part.value for part in subtitle.diffs if part.type != 'removed'])

        # 2. Convert timecodes to relative frames
        start_frames = timecode_to_frames(subtitle.startTimecode, frame_rate) - base_frames
        end_frames = timecode_to_frames(subtitle.endTimecode, frame_rate) - base_frames

        # 3. Format frames back to SRT timecode
        start_srt_time = frames_to_srt_timecode(max(0, start_frames), frame_rate)
        end_srt_time = frames_to_srt_timecode(max(0, end_frames), frame_rate)

        # 4. Assemble the SRT block
        srt_block = f"{index}\n{start_srt_time} --&gt; {end_srt_time}\n{clean_text}"
        srt_blocks.append(srt_block)

    # 5. Join all blocks with double newlines
    return "\n\n".join(srt_blocks)


def export_to_davinci(request: SubtitleExportRequest):
    """
    Exports subtitles to DaVinci Resolve by creating a temporary SRT file,
    importing it, and adding it to the timeline.
    """
    resolve, error = _connect_to_resolve()
    if error:
        return "error", error

    projectManager = resolve.GetProjectManager()
    project = projectManager.GetCurrentProject()
    if not project:
        return "error", {"code": "no_project_open", "message": "未找到当前打开的项目。"}

    media_pool = project.GetMediaPool()
    if not media_pool:
        return "error", {"code": "no_media_pool", "message": "无法获取媒体池。"}

    timeline, frame_rate, error = _get_current_timeline()
    if error:
        return "error", error

    start_tc_str = timeline.GetStartTimecode()
    base_frames = timecode_to_frames(start_tc_str, frame_rate)
    
    srt_content = generate_srt_content(request, base_frames)
    temp_file_path = ""
    try:
        # Create a temporary file to store the SRT content
        with tempfile.NamedTemporaryFile(mode='w+', suffix='.srt', delete=False, encoding='utf-8') as temp_file:
            temp_file_path = temp_file.name
            temp_file.write(srt_content)
            temp_file.flush() # Ensure content is written to disk
        
        logging.info(f"临时 SRT 文件已创建: {temp_file_path}")

        # Import the temporary SRT file into the media pool
        media_items = media_pool.ImportMedia([temp_file_path])
        if not media_items:
            logging.error("导入媒体文件失败。")
            return "error", {"code": "import_failed", "message": "导入媒体文件失败。"}
        
        # The API returns a list, we need the first item
        media_item = media_items[0]
        
        timeline = project.GetCurrentTimeline()
        if not timeline:
            return "error", {"code": "no_active_timeline", "message": "项目中没有活动的（当前）时间线。"}

        # 1. 显式轨道创建
        if not timeline.AddTrack("subtitle"):
            logging.error("无法创建新的字幕轨道。")
            return "error", {"message": "Failed to create a new subtitle track.", "code": "create_track_failed"}
        
        target_track_index = timeline.GetTrackCount("subtitle")
        logging.info(f"成功创建新的字幕轨道，索引为: {target_track_index}")

        # 2. 轨道隔离与状态保存
        original_track_states = {}
        total_subtitle_tracks = timeline.GetTrackCount("subtitle")
        
        # 先保存所有轨道的原始状态
        for i in range(1, total_subtitle_tracks + 1):
            original_track_states[i] = timeline.GetIsTrackEnabled("subtitle", i)

        try:
            # 禁用所有其他轨道，并显式启用目标轨道
            for i in range(1, total_subtitle_tracks + 1):
                if i != target_track_index:
                    timeline.SetTrackEnable("subtitle", i, False)
            timeline.SetTrackEnable("subtitle", target_track_index, True)
            logging.info(f"轨道隔离完成：仅启用目标轨道 {target_track_index}")

            # 3. 精确定位插入点
            if request.subtitles:
                first_subtitle_tc = request.subtitles[0].startTimecode
                timeline.SetCurrentTimecode(first_subtitle_tc)
                logging.info(f"播放头已移动到: {first_subtitle_tc}")

            # 4. 执行“粘贴”操作
            # 此时，因为只有一个字幕轨道是启用的，所以字幕会精确地添加到该轨道
            if not media_pool.AppendToTimeline([media_item]):
                logging.warning("AppendToTimeline 返回了 false 或 None，但这可能是预期的行为。")

        finally:
            # 根据用户要求，不再恢复轨道的原始状态，以保持新轨道为激活状态。
            pass

        logging.info("成功将字幕导入并附加到时间线。")
        return "success", {"message": "成功将字幕导出至 DaVinci Resolve。"}

    except Exception as e:
        logging.error(f"导出至 DaVinci Resolve 时出错: {e}", exc_info=True)
        return "error", {"code": "export_error", "message": f"导出至 DaVinci Resolve 时出错: {e}"}
    finally:
        # Clean up the temporary file
        if temp_file_path and os.path.exists(temp_file_path):
            try:
                os.remove(temp_file_path)
                logging.info(f"临时文件已删除: {temp_file_path}")
            except OSError as e:
                logging.error(f"删除临时文件时出错: {e}", exc_info=True)</content>
  </file>
  <file path="schemas.py" size="1775" modified_time="2025-08-12T11:38:58.783845" mime_type="text/x-python" content_type="text">
    <content>from pydantic import BaseModel, Field
from typing import List, Union
from enum import Enum

# --- Models for SRT Export ---

class DiffPartModel(BaseModel):
    type: str # 'added', 'removed', or 'normal'
    value: str

class SubtitleModel(BaseModel):
    id: int
    startTimecode: str
    endTimecode: str
    diffs: List[DiffPartModel]

class SubtitleExportRequest(BaseModel):
    frameRate: float
    subtitles: List[SubtitleModel]

# --- Models for Timeline ---

class SubtitleTrackInfo(BaseModel):
    track_index: int = Field(..., example=1, description="字幕轨道的索引（从1开始）")
    track_name: str = Field(..., example="Subtitle 1", description="字幕轨道的名称")

class SubtitleTrackListResponse(BaseModel):
    status: str = "success"
    data: List[SubtitleTrackInfo]


# --- Existing Models from main.py ---

class SubtitleItem(BaseModel):
    id: int
    startTimecode: str = Field(..., example="01:00:02:10")
    endTimecode: str = Field(..., example="01:00:05:15")
    text: str = Field(..., example="这是一条字幕。")

class SuccessResponse(BaseModel):
    status: str = "success"
    frameRate: float
    data: List[SubtitleItem]

class ErrorResponse(BaseModel):
    status: str = "error"
    message: str
    code: str

class JumpToOptions(str, Enum):
    start = "start"
    end = "end"
    middle = "middle"

class TimecodeRequest(BaseModel):
    in_point: str = Field(..., example="01:00:00:00", description="入点时间码，格式为 HH:MM:SS:FF")
    out_point: str = Field(..., example="01:00:10:00", description="出点时间码，格式为 HH:MM:SS:FF")
    jump_to: JumpToOptions = Field(..., description="跳转位置，可选值为 'start', 'end', 'middle'")</content>
  </file>
  <file path="timecode_utils.py" size="1344" modified_time="2025-08-07T13:39:00.740882" mime_type="text/x-python" content_type="text">
    <content>from timecode import Timecode

def format_timecode(frame, frame_rate):
    """将帧数转换为 HH:MM:SS:FF 格式的时间码"""
    if frame_rate == 0:
        return "00:00:00:00"
    
    # The Timecode library is 1-based. Frame 0 is a special case.
    if frame == 0:
        return "00:00:00:00"

    # Add 1 to the frame to match the 1-based indexing of the library
    tc = Timecode(frame_rate, frames=int(frame) + 1)
    return str(tc)

def timecode_to_frames(tc_str: str, frame_rate: float) -&gt; int:
    """Converts a timecode string (e.g., '01:00:00:00') to total frames."""
    tc = Timecode(frame_rate, tc_str)
    return tc.frames - 1

def frames_to_timecode(frames: int, frame_rate: float) -&gt; str:
    """Converts frame count to HH:MM:SS:FF."""
    return format_timecode(frames, frame_rate)

def frames_to_srt_timecode(frames: int, frame_rate: float) -&gt; str:
    """Converts frame count to HH:MM:SS,ms SRT timecode format."""
    if frame_rate == 0:
        return "00:00:00,000"
    
    total_seconds = frames / frame_rate
    hours = int(total_seconds / 3600)
    minutes = int((total_seconds % 3600) / 60)
    seconds = int(total_seconds % 60)
    milliseconds = int((total_seconds - int(total_seconds)) * 1000)
    
    return f"{hours:02d}:{minutes:02d}:{seconds:02d},{milliseconds:03d}"</content>
  </file>
  <file path="__init__.py" size="0" modified_time="2025-08-07T13:39:00.736383" mime_type="text/x-python" content_type="text">
    <content/>
  </file>
  <file path="tests\test_main.py" size="9160" modified_time="2025-08-11T10:23:12.315433" mime_type="text/x-python" content_type="text">
    <content>import unittest
from unittest.mock import patch, MagicMock
from fastapi.testclient import TestClient
import sys
import os

sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from main import app

class TestMainAPI(unittest.TestCase):

    def setUp(self):
        self.client = TestClient(app)

    @patch('main.set_resolve_timecode')
    def test_set_timecode_jump_to_start(self, mock_set_resolve_timecode):
        # Arrange
        in_point = "01:00:00:00"
        out_point = "01:00:10:00"
        jump_to = "start"
        mock_set_resolve_timecode.return_value = ("success", {"message": f"成功将时间码设置为: {in_point}"})

        # Act
        response = self.client.post(
            "/api/v1/timeline/timecode",
            json={"in_point": in_point, "out_point": out_point, "jump_to": jump_to}
        )

        # Assert
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.json(), {"status": "success", "message": f"成功将时间码设置为: {in_point}"})
        mock_set_resolve_timecode.assert_called_once_with(in_point=in_point, out_point=out_point, jump_to=jump_to)

    @patch('main.set_resolve_timecode')
    def test_set_timecode_jump_to_end(self, mock_set_resolve_timecode):
        # Arrange
        in_point = "01:00:00:00"
        out_point = "01:00:10:00"
        jump_to = "end"
        mock_set_resolve_timecode.return_value = ("success", {"message": f"成功将时间码设置为: {out_point}"})

        # Act
        response = self.client.post(
            "/api/v1/timeline/timecode",
            json={"in_point": in_point, "out_point": out_point, "jump_to": jump_to}
        )

        # Assert
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.json(), {"status": "success", "message": f"成功将时间码设置为: {out_point}"})
        mock_set_resolve_timecode.assert_called_once_with(in_point=in_point, out_point=out_point, jump_to=jump_to)

    @patch('main.set_resolve_timecode')
    def test_set_timecode_jump_to_middle(self, mock_set_resolve_timecode):
        # Arrange
        in_point = "01:00:00:00"
        out_point = "01:00:10:00"
        jump_to = "middle"
        middle_point = "01:00:05:00" # Assuming this is the calculated middle point
        mock_set_resolve_timecode.return_value = ("success", {"message": f"成功将时间码设置为: {middle_point}"})

        # Act
        response = self.client.post(
            "/api/v1/timeline/timecode",
            json={"in_point": in_point, "out_point": out_point, "jump_to": jump_to}
        )

        # Assert
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.json(), {"status": "success", "message": f"成功将时间码设置为: {middle_point}"})
        mock_set_resolve_timecode.assert_called_once_with(in_point=in_point, out_point=out_point, jump_to=jump_to)

    @patch('main.set_resolve_timecode')
    def test_set_timecode_resolve_not_running(self, mock_set_resolve_timecode):
        """Test the endpoint when DaVinci Resolve is not running."""
        # Arrange
        in_point = "01:00:00:00"
        out_point = "01:00:10:00"
        jump_to = "start"
        error_message = {"code": "resolve_not_running", "message": "无法连接到 DaVinci Resolve。"}
        mock_set_resolve_timecode.return_value = ("error", error_message)

        # Act
        response = self.client.post("/api/v1/timeline/timecode", json={"in_point": in_point, "out_point": out_point, "jump_to": jump_to})

        # Assert
        self.assertEqual(response.status_code, 503)
        self.assertEqual(response.json()['detail']['code'], "resolve_not_running")

if __name__ == '__main__':
    unittest.main(argv=['first-arg-is-ignored'], exit=False)

    @patch('main.get_subtitle_tracks')
    def test_get_subtitle_tracks_success(self, mock_get_tracks):
        """Test successfully getting the list of subtitle tracks."""
        # Arrange
        mock_data = [
            {"track_index": 1, "track_name": "English-Sub"},
            {"track_index": 2, "track_name": "Spanish-Sub"}
        ]
        mock_get_tracks.return_value = ("success", {"data": mock_data})

        # Act
        response = self.client.get("/api/v1/timeline/subtitle_tracks")

        # Assert
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.json(), {"status": "success", "data": mock_data})
        mock_get_tracks.assert_called_once()

    @patch('main.get_subtitle_tracks')
    def test_get_subtitle_tracks_no_tracks(self, mock_get_tracks):
        """Test getting an empty list when there are no subtitle tracks."""
        # Arrange
        mock_get_tracks.return_value = ("success", {"data": []})

        # Act
        response = self.client.get("/api/v1/timeline/subtitle_tracks")

        # Assert
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.json(), {"status": "success", "data": []})
        mock_get_tracks.assert_called_once()

    @patch('main.get_subtitle_tracks')
    def test_get_subtitle_tracks_resolve_error(self, mock_get_tracks):
        """Test handling an error from Resolve, like no active timeline."""
        # Arrange
        error_message = {"code": "no_active_timeline", "message": "No active timeline in the project."}
        mock_get_tracks.return_value = ("error", error_message)

        # Act
        response = self.client.get("/api/v1/timeline/subtitle_tracks")

        # Assert
        self.assertEqual(response.status_code, 404)
        self.assertEqual(response.json()['detail']['code'], "no_active_timeline")
        mock_get_tracks.assert_called_once()

    @patch('main.generate_srt_content')
    def test_export_subtitles_as_srt_success(self, mock_generate_srt_content):
        """Test successfully exporting subtitles as SRT."""
        # Arrange
        mock_srt_content = "1\n00:00:01,000 --&gt; 00:00:04,000\nHello, world!"
        mock_generate_srt_content.return_value = mock_srt_content
        
        request_data = {
            "frameRate": 24.0,
            "subtitles": [
                {
                    "id": 1,
                    "startTimecode": "00:00:01:00",
                    "endTimecode": "00:00:04:00",
                    "diffs": [
                        {"type": "normal", "value": "Hello, world!"}
                    ]
                }
            ]
        }

        # Act
        response = self.client.post("/api/v1/export/srt", json=request_data)

        # Assert
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.text, mock_srt_content)
        self.assertEqual(response.headers['content-type'], 'text/plain; charset=utf-8')
        mock_generate_srt_content.assert_called_once()

    @patch('main.export_to_davinci')
    def test_export_subtitles_to_davinci_success(self, mock_export_to_davinci):
        """Test successfully exporting subtitles to DaVinci Resolve."""
        # Arrange
        mock_export_to_davinci.return_value = ("success", {"message": "成功导出至达芬奇！"})
        
        request_data = {
            "frameRate": 24.0,
            "subtitles": [
                {
                    "id": 1,
                    "startTimecode": "00:00:01:00",
                    "endTimecode": "00:00:04:00",
                    "diffs": [
                        {"type": "normal", "value": "Hello, world!"}
                    ]
                }
            ]
        }

        # Act
        response = self.client.post("/api/v1/export/davinci", json=request_data)

        # Assert
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.json(), {"status": "success", "message": "成功导出至达芬奇！"})
        mock_export_to_davinci.assert_called_once()

    @patch('main.export_to_davinci')
    def test_export_subtitles_to_davinci_error(self, mock_export_to_davinci):
        """Test handling an error when exporting subtitles to DaVinci Resolve."""
        # Arrange
        error_message = {"code": "export_error", "message": "导出至达芬奇时发生错误"}
        mock_export_to_davinci.return_value = ("error", error_message)
        
        request_data = {
            "frameRate": 24.0,
            "subtitles": [
                {
                    "id": 1,
                    "startTimecode": "00:00:01:00",
                    "endTimecode": "00:00:04:00",
                    "diffs": [
                        {"type": "normal", "value": "Hello, world!"}
                    ]
                }
            ]
        }

        # Act
        response = self.client.post("/api/v1/export/davinci", json=request_data)

        # Assert
        self.assertEqual(response.status_code, 500)
        self.assertEqual(response.json()['detail']['code'], "export_error")
        mock_export_to_davinci.assert_called_once()</content>
  </file>
  <file path="tests\test_resolve_utils.py" size="5646" modified_time="2025-08-07T13:39:00.739882" mime_type="text/x-python" content_type="text">
    <content>import pytest
from unittest.mock import patch, MagicMock
import sys
import os

sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from resolve_utils import set_resolve_timecode

@pytest.fixture
def mock_resolve_setup():
    """Provides a mocked Resolve and Timeline object for tests."""
    mock_timeline = MagicMock()
    mock_timeline.GetSetting.return_value = '24.0'
    
    mock_project = MagicMock()
    mock_project.GetCurrentTimeline.return_value = mock_timeline
    
    mock_project_manager = MagicMock()
    mock_project_manager.GetCurrentProject.return_value = mock_project
    
    mock_resolve = MagicMock()
    mock_resolve.GetProjectManager.return_value = mock_project_manager
    return mock_resolve, mock_timeline

@patch('resolve_utils._connect_to_resolve')
def test_set_resolve_timecode_jump_to_start(mock_connect, mock_resolve_setup):
    """Tests jumping to the start timecode."""
    mock_resolve, mock_timeline = mock_resolve_setup
    mock_connect.return_value = (mock_resolve, None)
    
    in_point = "01:00:00:00"
    out_point = "01:00:10:00"
    
    status, result = set_resolve_timecode(in_point=in_point, out_point=out_point, jump_to="start")
    
    assert status == "success"
    assert in_point in result["message"]
    mock_timeline.SetCurrentTimecode.assert_called_once_with(in_point)

@patch('resolve_utils._connect_to_resolve')
def test_set_resolve_timecode_jump_to_end(mock_connect, mock_resolve_setup):
    """Tests jumping to the end timecode."""
    mock_resolve, mock_timeline = mock_resolve_setup
    mock_connect.return_value = (mock_resolve, None)
    
    in_point = "01:00:00:00"
    out_point = "01:00:10:00"
    
    status, result = set_resolve_timecode(in_point=in_point, out_point=out_point, jump_to="end")
    
    assert status == "success"
    assert out_point in result["message"]
    mock_timeline.SetCurrentTimecode.assert_called_once_with(out_point)

@patch('resolve_utils._connect_to_resolve')
@patch('resolve_utils.timecode_to_frames')
@patch('resolve_utils.frames_to_timecode')
def test_set_resolve_timecode_jump_to_middle(mock_frames_to_tc, mock_tc_to_frames, mock_connect, mock_resolve_setup):
    """Tests jumping to the middle timecode."""
    mock_resolve, mock_timeline = mock_resolve_setup
    mock_connect.return_value = (mock_resolve, None)
    
    in_point = "01:00:00:00"
    out_point = "01:00:10:00"
    middle_point = "01:00:05:00"

    mock_tc_to_frames.side_effect = [0, 240]
    mock_frames_to_tc.return_value = middle_point
    
    status, result = set_resolve_timecode(in_point=in_point, out_point=out_point, jump_to="middle")
    
    assert status == "success"
    assert middle_point in result["message"]
    mock_timeline.SetCurrentTimecode.assert_called_once_with(middle_point)
    mock_tc_to_frames.assert_any_call(in_point, 24.0)
    mock_tc_to_frames.assert_any_call(out_point, 24.0)
    mock_frames_to_tc.assert_called_once_with(120, 24.0)

@patch('resolve_utils._connect_to_resolve')
def test_set_resolve_timecode_connection_error(mock_connect, mock_resolve_setup):
    """Tests handling of a Resolve connection error."""
    mock_resolve, _ = mock_resolve_setup
    error_message = {"code": "resolve_not_running", "message": "无法连接到 DaVinci Resolve。"}
    mock_connect.return_value = (None, error_message)
    
    status, result = set_resolve_timecode("00", "00", "start")
    
    assert status == "error"
    assert result == error_message

from resolve_utils import get_subtitle_tracks
from schemas import SubtitleTrackInfo

@patch('resolve_utils._get_current_timeline')
def test_get_subtitle_tracks_success(mock_get_timeline, mock_resolve_setup):
    """Tests successfully retrieving a list of subtitle tracks."""
    _, mock_timeline = mock_resolve_setup
    mock_get_timeline.return_value = (mock_timeline, 24.0, None)
    
    mock_timeline.GetTrackCount.return_value = 2
    mock_timeline.GetTrackName.side_effect = ["Track 1", "Track 2"]
    
    status, result = get_subtitle_tracks()
    
    assert status == "success"
    assert len(result["data"]) == 2
    assert result["data"][0] == SubtitleTrackInfo(track_index=1, track_name="Track 1")
    assert result["data"][1] == SubtitleTrackInfo(track_index=2, track_name="Track 2")
    mock_timeline.GetTrackCount.assert_called_once_with("subtitle")
    mock_timeline.GetTrackName.assert_any_call("subtitle", 1)
    mock_timeline.GetTrackName.assert_any_call("subtitle", 2)

@patch('resolve_utils._get_current_timeline')
def test_get_subtitle_tracks_no_tracks(mock_get_timeline, mock_resolve_setup):
    """Tests the case where there are no subtitle tracks on the timeline."""
    _, mock_timeline = mock_resolve_setup
    mock_get_timeline.return_value = (mock_timeline, 24.0, None)
    
    mock_timeline.GetTrackCount.return_value = 0
    
    status, result = get_subtitle_tracks()
    
    assert status == "success"
    assert result["data"] == []
    mock_timeline.GetTrackCount.assert_called_once_with("subtitle")

@patch('resolve_utils._get_current_timeline')
def test_get_subtitle_tracks_connection_error(mock_get_timeline):
    """Tests handling of a connection error when getting subtitle tracks."""
    error_message = {"code": "no_active_timeline", "message": "项目中没有活动的（当前）时间线。"}
    mock_get_timeline.return_value = (None, None, error_message)
    
    status, result = get_subtitle_tracks()
    
    assert status == "error"
    assert result == error_message</content>
  </file>
  <file path="tests\test_timecode_utils.py" size="1188" modified_time="2025-08-07T13:39:00.740382" mime_type="text/x-python" content_type="text">
    <content>import pytest
from backend.timecode_utils import format_timecode

def test_format_timecode_zero_frame_rate():
    """
    Test that format_timecode handles a frame rate of 0 correctly.
    """
    assert format_timecode(100, 0) == "00:00:00:00"

def test_format_timecode_zero_frame():
    """
    Test that format_timecode handles frame 0 correctly.
    """
    assert format_timecode(0, 24) == "00:00:00:00"

def test_format_timecode_normal():
    """
    Test that format_timecode works for a normal case.
    """
    # At 24 fps, frame 23 should be 00:00:00:23
    # The library is 1-based, so frame 23 is the 24th frame, which is 00:00:01:00.
    # The code adds 1 to the frame, so `format_timecode(23, 24)` will calculate for frame 24.
    # Let's test frame 22, which should be timecode 00:00:00:23
    assert format_timecode(22, 24) == "00:00:00:22"
    
    # Frame 24 should be 00:00:01:00
    assert format_timecode(23, 24) == "00:00:00:23"

    # A larger frame number
    # Frame 24 should be 00:00:01:00
    assert format_timecode(24, 24) == "00:00:01:00"

    # A larger frame number
    assert format_timecode(172800, 24) == "02:00:00:00"
</content>
  </file>
  <file path="tests\__init__.py" size="0" modified_time="2025-08-07T13:39:00.739382" mime_type="text/x-python" content_type="text">
    <content/>
  </file>
</code_package>
